/*
描述
给出两个整数 aa 和 bb , 求他们的和。

你不需要从输入流读入数据，只需要根据aplusb的两个参数a和b，计算他们的和并返回就行。

说明
a和b都是 32位 整数么？
是的
我可以使用位运算符么？
当然可以

样例
如果 a=1 并且 b=2，返回3。

挑战
显然你可以直接 return a + b，但是你是否可以挑战一下不这样做？（不使用++等算数运算符）
*/
class Solution {
public:

    int aplusb(int a, int b) {
        int sum=a^b;
        int carry=(a&b)<<1;
        return carry==0?sum:aplusb(sum,carry);
    }
};

//位运算https://www.jianshu.com/p/7bba031b11e7
/*其中
先来个我们最熟悉的十进制的加法运算：

13 + 9 = 22

我们像这样来拆分这个运算过程：

不考虑进位，分别对各位数进行相加，结果为sum：
个位数3加上9为2；十位数1加上0为1； 最终结果为12；

只考虑进位，结果为carry：
3 + 9 有进位，进位的值为10；

如果步骤2所得进位结果carry不为0，对步骤1所得sum，步骤2所得carry重复步骤1、 2、3；如果carry为0则结束，最终结果为步骤1所得sum：
这里即是对sum = 12 和carry = 10重复以上三个步骤，(a) 不考虑进位，分别对各位数进行相加:sum = 22; (b) 只考虑进位: 上一步没有进位，所以carry = 0； (c) 步骤2carry = 0，结束，结果为sum = 22.

我们发现这三板斧行得通！

那我们现在还使用上面的三板斧把十进制运算放在二进制中看看是不是也行的通。

13的二进制为0000 1101，9的二进制为0000 1001:

不考虑进位，分别对各位数进行相加：
sum = 0000 1101 + 0000 1001 = 0000 0100

考虑进位：
有两处进位，第0位和第3位，只考虑进位的结果为：
carry = 0001 0010

步骤2carry == 0 ?，不为0，重复步骤1 、2 、3；为0则结束，结果为sum：
本例中，
(a)不考虑进位sum = 0001 0110;
(b)只考虑进位carry = 0;
(c)carry == 0，结束，结果为sum = 0001 0110
转换成十进制刚好是22.

我们发现，适用于十进制的三板斧同样适用于二进制！仔细观察者三板斧，大家能不能发现其实第一步不考虑进位的加法其实就是异或运算；而第二部只考虑进位就是与运算并左移一位--；第三步就是重复前面两步操作直到第二步进位结果为0。

这里关于第三步多说一点。为什么要循环步骤1、 2、 3直到步骤2所得进位carry等于0？其实这是因为有的数做加法时会出现连续进位的情况，举例：3 + 9，我们来走一遍上述逻辑：

a = 0011, b = 1001;
start;

first loop;
1.1 sum = 1010
1.2 carry = 0010
1.3 carry != 0 , go on;

second loop;
2.1 sum = 1000;
2.2 carry = 0100;
2.3 carry != 0, go on;

third loop;
3.1 sum = 1100;
3.2 carry = 0000;
3.3 carry == 0, stop; result = sum;

end

如上面的栗子，有的加法操作是有连续进位的情况的，所以这里要在第三步检测carry是不是为0，如果为0则表示没有进位了，第一步的sum即为最终的结果。

有了上面的分析，我们不难写出如下代码：

// 递归写法
int add(int num1, int num2){
    if(num2 == 0)
        return num1;
    int sum = num1 ^ num2;
    int carry = (num1 & num2) << 1;
    return add(sum, carry);
}

// 迭代写法
int add(int num1, int num2){
    int sum = num1 ^ num2;
    int carry = (num1 & num2) << 1;  
    while(carry != 0){
        int a = sum;
        int b = carry;
        sum = a ^ b;
        carry = (a & b) << 1;  
    }
    return sum;
}
我们的计算机其实就是通过上述的位运算实现加法运算的（通过加法器，加法器就是使用上述的方法实现加法的），而程序语言中的+ - * /
运算符只不过是呈现给程序员的操作工具，计算机底层实际操作的永远是形如0101的位，所以说位运算真的很重要！
*/
